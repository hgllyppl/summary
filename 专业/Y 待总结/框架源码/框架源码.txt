
# spring-jdbc(初始化/执行/架构)
ifeve.com/实战spring事务传播性与隔离性
声明式事务 -> DefaultPointcutAdvisor -> AspectJExpressionPointcut, TransactionInterceptor(不要命名为transactionInterceptor会被覆盖)
           -> 切点不是精准覆盖，其他方法也会执行advice，但不会执行事务，因为得不到txAttr，没有必要精准覆盖，因为代理的是class
声明式事务、注解式事务 混合 = 嵌套事务，嵌套事务的执行参考propagation-behavior以及调试代码
                            -> required类型的嵌套，内层不会提交和回滚事务，由外层执行，判断逻辑是TransactionStatus.isNewTransaction

TransactionInterceptor -> PlatformTransactionManager -> ... -> ConnectionHolder[bindThread{DataSource|ConnectionHolder}]

JdbcTemplate        |  -> DataSource -> ConnectionHolder
SqlSessionTemplate  |  -> SqlSessionHoler[bindThread{SqlSessionFactory|SqlSessionHolder}] -> ... -> DataSource -> ConnectionHolder

# spring事务
https://www.iteye.com/topic/35907
http://ifeve.com/%E5%AE%9E%E6%88%98spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%80%A7%E4%B8%8E%E9%9A%94%E7%A6%BB%E6%80%A7/

# spring-mvc(初始化/执行/架构)
架构1
DelegatingWebMvcConfiguration.WebMvcConfigurerComposite.WebMvcConfigurer

初始化1
WebMvcAutoConfiguration
  -> WebMvcAutoConfigurationAdapter extends WebMvcConfigurerAdapter extends WebMvcConfigurer
  -> EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport

初始化2
finishBeanFactoryInitialization
  -> getBean(RequestMappingHandlerMapping)
    -> bean.afterPropertiesSet
      -> find Beans with @Controller/@RequestMapping
      -> detectHandlerMethods
        -> findMethods with @RequestMapping -> Map<Method, RequestMappingInfo>
        -> ITER methodsMap -> registerHandlerMethod
            -> mappingRegistry.register(mapping, handler, method)
                -> (handler, method) -> HandlerMethod
                -> urlLookup MultiValueMap<String, RequestMappingInfo>
                -> mappingLookup Map<RequestMappingInfo, HandlerMethod>
                -> registry Map<RequestMappingInfo, MappingRegistration<RequestMappingInfo>>
  -> getBean(RequestMappingHandlerAdapter)???
      -> afterPropertiesSet
          -> initControllerAdviceCache
              -> ControllerAdviceBean.findAnnotatedBeans(ctx) && AnnotationAwareOrderComparator.sort(beans)
              -> requestResponseBodyAdviceBeans.add(bean)
          -> getDefaultArgumentResolvers
          -> getDefaultReturnValueHandlers
  -> getBean(ExceptionHandlerExceptionResolver)???
      -> afterPropertiesSet
          -> initExceptionHandlerAdviceCache
              -> ControllerAdviceBean.findAnnotatedBeans(ctx) && AnnotationAwareOrderComparator.sort(beans)
              -> exceptionHandlerAdviceCache.put(adviceBean, resolver)
              -> responseBodyAdvice.add(adviceBean)
          -> getDefaultArgumentResolvers
          -> getDefaultReturnValueHandlers
  -> getBean(other mvc config)

初始化3
HttpServletBean.init???
DispatchServlet.onRefresh
  -> initMultipartResolver(context);
  -> initLocaleResolver(context);
  -> initThemeResolver(context);
  -> initHandlerMappings(context);
  -> initHandlerAdapters(context);
  -> initHandlerExceptionResolvers(context);
  -> initRequestToViewNameTranslator(context);
  -> initViewResolvers(context);
  -> initFlashMapManager(context);

执行
HttpServlet.service -> FrameworkServlet.service -> HttpServlet.service
  -> switch(method) -> FrameworkServlet.doGet/doPost/doPut/doDelete/doOptions/doTrace -> processRequest
    -> initContextHolders
    -> doService
      -> request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE/LOCALE_RESOLVER_ATTRIBUTE/THEME_RESOLVER_ATTRIBUTE/THEME_SOURCE_ATTRIBUTE)
      -> request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE/OUTPUT_FLASH_MAP_ATTRIBUTE/FLASH_MAP_MANAGER_ATTRIBUTE)
      -> doDispatch
        -> mappedHandler[HandlerExecutionChain] = getHandler
            -> ITER handlerMappings
                -> hm.getHandler[RequestMappingHandlerMapping]
                    -> getHandlerInternal
                        -> url = getUrlPathHelper().getLookupPathForRequest
                        -> lookupHandlerMethod
                            -> url -> RequestMappingInfo -> HandlerMethod
                    -> getHandlerExecutionChain
                        -> chain = new HandlerExecutionChain
                        -> chain.addInterceptor
        -> handlerAdapter = getHandlerAdapter
            -> ITER handlerAdapters
                -> ha.supports[RequestMappingHandlerAdapter]
                    -> handler instanceof HandlerMethod && supportsInternal((HandlerMethod) handler)
        -> mappedHandler.applyPreHandle -> interceptor.preHandle
        -> handlerAdapter.handle
            -> invokeHandlerMethod
                -> getDataBinderFactory -> ...
                -> getModelFactory -> ...
                -> createInvocableHandlerMethod -> setHandlerMethodArgumentResolvers/setHandlerMethodReturnValueHandlers/setDataBinderFactory/setParameterNameDiscoverer
                -> mavContainer -> ...
                -> invocableMethod.invokeAndHandle
                    -> invokeForRequest
                        -> getMethodArgumentValues
                            -> ...
                            -> argumentResolvers.resolveArgument
                                -> getArgumentResolver -> ITER argumentResolvers & supportsParameter
                                -> resolver.resolveArgument[RequestResponseBodyMethodProcessor/RequestParamMethodArgumentResolver]
                                    -> getAdvice().beforeBodyRead
                                    -> converter.read
                                    -> getAdvice().afterBodyRead
                        -> doInvoke -> method.invoke
                    -> returnValueHandlers.handleReturnValue
                        -> selectHandler -> ITER returnValueHandlers & supportsReturnType
                        -> handler.handleReturnValue[RequestResponseBodyMethodProcessor]
                            -> getAdvice().beforeBodyWrite
                            -> converter.write
                -> getModelAndView -> ...
        -> mappedHandler.applyPostHandle -> interceptor.postHandle
        -> processDispatchResult
            -> handleException
            -> handleModeAndView
            -> mappedHandler.triggerAfterCompletion -> interceptor.afterCompletion
    -> resetContextHolders
    -> publishRequestHandledEvent

# spring-scheduling
ScheduledAnnotationBeanPostProcessor
 - findMethod(Map<Method, Set<Scheduled>>)
 - registrar.scheduleCronTask
ScheduledTaskRegistrar
 - scheduleTasks
TaskScheduler
 - schedule

# dbcp???
...

# mybatis
...

# springboot(初始化/架构)
boot-start
LaunchedURLClassLoader -> load all jar -> exec main

SpringApplication.run
SpringApplicationRunListeners
listeners.starting/environmentPrepared/contextPrepared/contextLoaded/finished

super.refresh ->  ...
              ->  invokeBeanFactoryPostProcessors -> AutoConfigurationImportSelector -> import AutoConfigurationClass
              ->  ...
              ->  super.onRefresh
                    -> getEmbeddedServletContainerFactory
                    -> getEmbeddedServletContainer
                        -> tomcat.start()[Main] -> server.start() -> services[i].start() -> engine.start() -> host.start()[TomcatThread] -> context.start() [LocalhostThread]
                            -> selfInitialize
                                -> prepareEmbeddedWebApplicationContext
                                    -> servletContext.setAttribute("org.springframework.web.context.WebApplicationContext.ROOT", ctx)
                                    -> ctx.setServletContext
                                -> WebApplicationContextUtils.registerWebApplicationScopes
                                    -> beanFactory.registerScope(WebApplicationContext.SCOPE_REQUEST/SCOPE_SESSION/SCOPE_GLOBAL_SESSION/SCOPE_APPLICATION, new RequestScope())
                                -> WebApplicationContextUtils.registerEnvironmentBeans
                                    -> INN servletContext THEN beanFactory.registerSingleton("servletContext", servletContext)
                                    -> INN servletConfig THEN beanFactory.registerSingleton("servletConfig", servletConfig)
                                    -> INE contextParameters THEN beanFactory.registerSingleton("contextParameters", parameterMap)
                                    -> INE contextAttributes THEN beanFactory.registerSingleton("contextAttributes", attributeMap)
                                -> new ServletContextInitializerBeans extends AbstractCollection<ServletContextInitializer>
                                    -> getBean(ServletContextInitializer/Servlet/Filter/EventListener.class)[会过滤已经注册的bean]
                                    -> addBean 2 list
                                -> ITER ServletContextInitializerBeans
                                    -> ServletContextInitializer.onStartup
                                        -> ServletRegistrationBean
                                            -> servletContext.addServlet & configure
                                        -> FilterRegistrationBean
                                            -> servletContext.addFilter & configure
                                        -> ServletListenerRegistrationBean
                                            -> servletContext.addListener
              ->  ...
              ->  super.finishRefresh
                    -> startEmbeddedServletContainer -> localContainer.start() -> addPreviouslyRemovedConnectors(bind socket)

boot-autoconfigure
autoconfigure -> ConditionalOn & ConditionalOnMissing & more 决定启用自动配置，大部分配置是你不配它就配，你配了它就不配，例 TransactionAutoConfiguration

# Spring 框架的设计理念与设计模式分析
https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/

# 完全读懂Spring框架之AOP实现原理
https://my.oschina.net/guangshan/blog/1797461

# http-client

# dbcp基本配置和重连配置
https://agapple.iteye.com/blog/772507

# springboot 使用
https://blog.csdn.net/hry2015/article/details/78127567?utm_source=tuicool&utm_medium=referral
https://blog.csdn.net/m0_37893932/article/details/78203144
https://www.jianshu.com/p/259bbe6d81c2
